{"id":"source-a97","title":"Add bounds checking to TERM_$STATUS_CONVERT","status":"open","priority":4,"issue_type":"task","created_at":"2026-01-12T10:35:28.559937-08:00","created_by":"toshok","updated_at":"2026-01-12T10:35:28.559937-08:00"}
{"id":"source-bl7","title":"Implement PROC1_$ (Process Management) module","description":"Implement the PROC1_$ process management API with 50+ functions.\n\n## Functions identified:\n### Process lifecycle:\n- PROC1_$CREATE_P, PROC1_$BIND, PROC1_$UNBIND\n- PROC1_$SUSPEND, PROC1_$SUSPENDP, PROC1_$RESUME, PROC1_$TRY_TO_SUSPEND\n\n### Scheduling/Ready list:\n- PROC1_$DISPATCH, PROC1_$DISPATCH_INT, PROC1_$DISPATCH_INT2, PROC1_$DISPATCH_INT3\n- PROC1_$ADD_READY, PROC1_$REMOVE_READY, PROC1_$REORDER_READY\n- proc1_$remove_from_ready_list, proc1_$insert_into_ready_list, proc1_$reorder_if_needed\n\n### Locking:\n- PROC1_$SET_LOCK, PROC1_$CLR_LOCK, PROC1_$TST_LOCK, PROC1_$GET_LOCKS\n\n### Atomic operations:\n- PROC1_$BEGIN_ATOMIC_OP, PROC1_$END_ATOMIC_OP\n- PROC1_$INHIBIT_BEGIN, PROC1_$INHIBIT_END, PROC1_$INHIBIT_CHECK\n\n### Event count integration:\n- PROC1_$EC_WAITN\n\n### CPU/Load tracking:\n- PROC1_$GET_CPUT, PROC1_$GET_CPUT8, PROC1_$GET_CPU_USAGE, PROC1_$GET_ANY_CPUT, PROC1_$GET_ANY_CPU_USAGE\n- PROC1_$GET_LOADAV, PROC1_$LOADAV_CALLBACK, PROC1_$INIT_LOADAV\n\n### Other:\n- PROC1_$INIT, PROC1_$SET_ASID, PROC1_$SET_PRIORITY, PROC1_$SET_TYPE, PROC1_$GET_TYPE\n- PROC1_$VT_INT, PROC1_$SET_VT, PROC1_$SET_TS, PROC1_$TS_END_CALLBACK\n- PROC1_$ALLOC_STACK, PROC1_$FREE_STACK, PROC1_$GET_INFO, PROC1_$GET_LIST, PROC1_$GET_USP\n\n## PCB structure discovered:\n- 0x00: nextp, 0x04: prevp (ready list links)\n- 0x08-0x34: saved D2-D7, A2-A6, A7 registers\n- 0x38: saved USP\n- 0x3c: wait_start\n- 0x40: resource_locks_held (priority/lock bitmask)\n- 0x44: mypid, 0x46: asid\n- 0x48: vtimer, 0x4c-0x50: cpu_total/usage\n- 0x52: state, 0x54-0x55: pri_min/flags\n\n## Key globals:\n- PROC1_$CURRENT_PCB: 0xe1eac8\n- PROC1_$CURRENT: 0xe20608\n- PROC1_$READY_PCB: PC-relative\n- PROC1_$ATOMIC_OP_DEPTH: 0xe2060e\n- PCBS table: 0xe1eacc\n\n## Assembly patterns:\n- ori #0x700,SR / andi #-0x701,SR for interrupt disable/enable\n- movem.l for register save/restore in context switch\n- USP manipulation for user/supervisor stack handling","status":"in_progress","priority":1,"issue_type":"feature","created_at":"2026-01-13T12:06:10.257198-08:00","created_by":"toshok","updated_at":"2026-01-13T12:17:24.157336-08:00"}
{"id":"source-c0n","title":"Replace DTTE #define offsets with properly padded struct","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-12T14:43:56.802285-08:00","created_by":"toshok","updated_at":"2026-01-12T15:32:06.396403-08:00","closed_at":"2026-01-12T15:32:06.396403-08:00","close_reason":"Replaced DTTE #defines with properly padded dtte_t struct with named fields. Updated all term/*.c files to use struct access."}
{"id":"source-e7v","title":"PROC2_$ API Implementation","description":"Implementation of PROC2_$ high-level process management API. This module provides:\n- Process creation, forking, and deletion\n- Process naming and identification (UIDs, UPIDs)\n- Signal handling (BSD-style signals)\n- Process groups\n- Process information queries\n- Debug support\n\n64 functions identified. Structure analysis shows:\n- Process info table at 0xEA551C (228 bytes per entry)\n- Mapping table at 0xEA93D2 (PROC1 PID to PROC2 index)\n- Lock ID 4 for PROC2 operations\n\nCurrent progress: Header with 64 function declarations, 5 implementations","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-13T13:09:42.396454-08:00","created_by":"toshok","updated_at":"2026-01-13T13:09:50.088821-08:00"}
{"id":"source-fzg","title":"Identify and type all DAT_* unknown data in term/ directory","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-12T14:43:56.729649-08:00","created_by":"toshok","updated_at":"2026-01-12T14:43:56.729649-08:00"}
{"id":"source-k7f","title":"Continue PROC2_$ module implementation","description":"Continue implementing the PROC2_$ high-level process management module.\n\n## Progress\n- **Implemented**: ~45 of 76 functions\n- **Remaining**: ~31 functions\n\n## Implemented Functions\nfind_asid, find_index, get_asid, get_boot_flags, get_cpu_usage,\nget_debugger_pid, get_my_upids, get_pid, get_sig_mask, get_tty_data,\nget_upids, list, list_pgroup, list2, my_pid, name_to_uid,\npguid_to_upgid, quit, set_cleanup, set_name, set_priority, set_server,\nset_stack_trunc_size, set_tty, sigblock, sigsetmask, uid_to_upid,\nupgid_to_uid, upid_to_uid, who_am_i, zombie_list, align_ctl\n\n### Process Control (NEW)\nSUSPEND, RESUME, MAKE_ORPHAN, SHUTDOWN\n\n### Signal Handling (NEW)\nSIGNAL, SIGNAL_OS, SIGNAL_PGROUP, SIGNAL_PGROUP_OS,\nSIGNAL_PGROUP_INTERNAL, ACKNOWLEDGE, DELIVER_FIM, SET_SIG_MASK, SIGPAUSE\n\n## Remaining Functions by Category\n\n### Signal Handling\n- DELIVER_SIGNAL_INTERNAL, DELIVER_PENDING_INTERNAL\n- DELIVER_PENDING, SIGRETURN, LOG_SIGNAL_EVENT\n\n### Process Creation/Deletion\n- INIT, CREATE, FORK, DELETE\n- STARTUP, SET_VALID, COMPLETE_FORK, COMPLETE_VFORK\n\n### Process Information\n- INFO, GET_INFO, BUILD_INFO_INTERNAL\n- GET_EC, GET_CR_REC, GET_REGS\n\n### Process Groups\n- SET_PGROUP, PGROUP_INFO, UID_TO_PGROUP_INDEX\n\n### Debug Support\n- DEBUG, OVERRIDE_DEBUG, UNDEBUG\n\n### Miscellaneous\n- AWAKEN_GUARDIAN, WAIT\n- SET_SESSION_ID, SET_ACCT_INFO\n\n## Notes\n- All code in proc2/ directory\n- Header file: proc2/proc2.h\n- proc2_info_t type created in Ghidra (228 bytes)\n- Many functions share patterns: ML_$LOCK(4), FIM_$CLEANUP, entry lookup","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-13T16:42:26.528796-08:00","created_by":"toshok","updated_at":"2026-01-13T18:48:09.11825-08:00"}
{"id":"source-r1l","title":"Revisit CPU architecture vs SAU vs feature-level code organization","description":"The current code organization uses SAU (System Architecture Unit) numbers for platform-specific code splits (e.g., ec/sau2/advance.s). However, this conflates several different concerns:\n\n1. **CPU architecture** (m68k vs x86 vs ARM) - instruction set, calling conventions, register usage\n2. **SAU variants** (sau1, sau2, etc.) - Apollo-specific hardware configurations\n3. **Feature-level differences** - e.g., MMU type, peripheral support\n\nThe ec/sau2/*.s files contain m68k assembly for SR (Status Register) manipulation to disable/enable interrupts. This is fundamentally a CPU architecture concern, not an SAU-level concern - the same code would work on any m68k-based SAU.\n\nConsider reorganizing to something like:\n- `ec/arch/m68k/` for m68k-specific assembly\n- `ec/arch/x86/` for x86 equivalents (when porting)\n- Keep SAU-level splits only for actual hardware variant differences\n\nThis would make the retargetability goal clearer and avoid confusion about what each directory level represents.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-13T11:18:14.179673-08:00","created_by":"toshok","updated_at":"2026-01-13T11:18:14.179673-08:00"}
